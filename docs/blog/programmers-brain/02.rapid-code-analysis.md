> 이 포스팅은 [프로그래머의 뇌](http://www.yes24.com/Product/Goods/105911017)를 읽고 작성하였습니다.

[comment]: <> (코드 더 잘 읽기&#40;1&#41;: 신속한 코드 분석)

## Overview

* 경험 많은 개발자조차 코드를 빨리 이해하는 것이 어려운 이유
* 두뇌가 정보들을 어떻게 인식 가능한 부분으로 나누는지 이해
* 단어와 코드 같은 정보를 분석할 때 LTM과 STM 사이의 상호작용

[comment]: <> (* 코드 분석 시 영상 기억 공간의 역할)

[comment]: <> (* 코드 기억을 통한 코딩 수준의 자가 진단)

[comment]: <> (* 읽기 쉬운 코드를 작성하는 법)

프로그래머가 일하는 시간 중 약 60%가 작성하는 게 아니라 이해하는 데 사용됩니다. 따라서 코드를 빨리 이해할 수 있다면 프로그래밍 기술이 크게 개선된다고 할 수 있습니다.

코드를 읽을 때 정보가 처음 저장되는 곳은 STM이라는 것은 앞서 살펴봤는데요, 코드의 많은 정보를 처리하는 게 왜 어려운 일인지 알아보겠습니다. 코드를 빨리 읽을 때 두뇌에서 무슨 일이 일어나는지 알면 코드를 얼마나 잘 이해하고 있는지 스스로 확인하기 더 쉽기 때문입니다.

## 코드 신속하게 읽기

"프로그램은 사람이 읽을 수 있도록 작성해야 한다. 기계가 실행하는 것은 부차적인 일이다."라는 유명한 문장이 있습니다. 하지만 현실적으로 프로그래머들은 코드를 읽는 방법보다 작성하는 법을 훨씬 더 많이 연습합니다.

처음 배울 때부터 코드를 만들어내는 것에 관심을 많이 가질 수 밖에 없는 구조입니다. 대학에서도, 직장에서도, 부트캠프에서도 일단 코드를 작성하는 것에 훨씬 더 많은 관심을 가집니다. 문제를 어떻게 풀어야하고 그것을 코드로 어떻게 코드로 구현하는지를 집중적으로 훈련하기 때문입니다. 따라서 코드를 읽는 연습을 할 기회는 많지 않습니다.

기능을 추가하거나 버그를 찾거나, 기존 시스템을 이해하기 위해서 우리는 코드를 읽습니다. 코드를 읽을 때 공통점은 코드 내에 존재하는 특정한 정보를 찾는 다는 점입니다. 새로운 기능을 어디에 추가할지, 마지막으로 수정한 곳 중 버그가 있을 만한 곳, 특정 메서드가 어떻게 구현되었는지 등이 특정한 정보에 해당합니다.

관련 정보를 신속하게 찾는 능력을 향상시킨다면 코드를 다시 찾아보는 횟수를 줄일 수 있고, 수준이 높아지면 추가 정보를 찾기 위해 여기저기 코드를 탐험하는 횟수 역시 줄어들게 됩니다. 왜 누구는 코드를 금방 파악하고 누구는 같은 곳을 계속해서 참조해서 보는지 알 수 있는 부분입니다.

### 코드를 읽을 때 두뇌 활동

자바로 구현된 삽입정렬 프로그램 코드를 읽는다고 가정해봅시다. 코드를 직접 여기 옮기진 않았지만 벌써부터 머리에 떠오르는 내용이 있으실 겁니다. 인터넷에서 대충 insertion sort로 검색해서 나온 코드를 3분동안 본 뒤 그대로 재현할 수 있을까요? 아마 경험이 많은 개발자이거나 알고리즘에 관심이 있거나, 또는 정렬 알고리즘을 배운 학생들이 시험 공부를 위해 자세히 본 경험이 있다면 아주 유사하게 작성 가능할 것입니다.

코드를 읽는 과정에서 정보들이 먼저 STM에 저장된 뒤 문법에 관한 지식은 LTM에서 가져오게 됩니다. 그리고 삽입정렬이라는 알고리즘을 알고있게되면 원소를 서로 swap 하는 과정을 까먹었더라도 LTM에서 꺼내 작성할 수 있습니다.

물론 어떤 부분을 LTM에서 꺼내게 될지는 어떤 것을 기억하고있느냐에 따라 사람마다 다릅니다. 자바 초보자는 LTM에서 꺼낼 기억이 별로 없기 때문에 대부분 STM에 저장했을 수도 있습니다. 그리고 원래 코드에는 없던 주석문이 추가되는 경우도 있습니다. 원소를 swap하는 과정을 알고있다면 다른 부분의 기억이 휘발되기 전에 다른 부분부터 작성하기 위해 swap 할 부분에 주석으로 간단히 적어놓고 다른 부분을 작성할 수도 있습니다.

### 두 번째 실험

삽입정렬은 우리가 대부분 잘 알고있는 알고리즘이고 프로그램 코드로 보더라도 익숙하게 받아들일 수 있습니다.

하지만 아래와 같은 코드를 같은 시간동안 보고 따라한다면 어떻게 될까요?

```java
public class Test {

  public void execute(int x[]) {
    for (int v = b / 2 - 1; v >= 0; v--) {
      func(x, b, v);
    }
    for (int l = b - 1; l > 0; l--) {
      int temp = x[0];
      x[0] = x[l];
      x[l] = tmp;
      func(x, l, 0);
    }
  }
}
```

아무리 자바에 익숙한 사람이라도 위의 코드를 보고 재현하는 것이 훨씬 어려웠을 거라는 것에는 모두 동의하실 겁니다. 우선 코드가 무슨 일을 하는지 알지 못하기 때문에 LTM에 저장된 지식을 사용할 수 없기 때문이고, 두 번째로 변수명을 의도적으로 헷갈리게 정하였기 때문입니다.

### 생소한 코드는 왜 어려운가?

위 코드가 기억하기 어려운 이유는 STM의 용량에 제한이 있기 때문입니다.

코드에 있는 모든 정보를 STM에 저장한 뒤 처리하는 것은 물리적으로 불가능합니다. STM은 읽거나 들은 정보를 짧은 시간만 저장하기 때문인데, 여기서 말하는 짧은 시간은 연구에 의하면 30초를 넘지 않는다고 합니다. 그 이후엔 LTM에 저장되거나 잊혀지게 됩니다.

STM은 시간 뿐만 아니라 크기도 제한됩니다. 최근 연구에 따르면 고작 2~6개 사이 또는 심지어 더 적다고 추정하고 있습니다. 이러한 용량을 극복하기 위해 LTM과 협업이 반드시 필요합니다.

## 기억의 크기 제한 극복

STM은 최대 6개까지만 기억할 수 있다고 합니다. 심지어 최대 6개에서 기억하는 것만 해당하는 것이 아니고 모든 인지 작업도 이에 해당한다고 합니다. 이렇게 제한된 기억력으로 어떻게 다른 많은 일들을 할 수 있을까요?

### 단위로 묶기

네덜란드 수학자 아드리한 더흐로트는 청크라는 개념을 처음 사용했습니다. 기억의 작은 단위들을 묶어서 청크로 만들고 그 청크 자체를 하나의 단위로 인식하는 것입니다.

체스 복기를 전문가 집단과 비전문가 집단으로 나누어서 실험을 진행하였는데, 전문가 집단이 훨씬 더 많은 부분을 기억해냈습니다. 그리고나서 체스 말을 임의로 배치한 뒤 다시 진행했을 때는 두 집단의 차이가 거의 없었습니다.

체스에는 '시실리언 오프닝' 등 흔히 말하는 '족보'가 있습니다. 넷플릭스에서 퀸스 갬빗이라는 미드를 보신 분들은 더 잘 아실텐데요, 처음 말을 어떻게 움직일 것인지, 그리고 상대가 어떤 족보를 사용하면 나는 어떻게 대응할 것인지에 대한 정보가 전문가들의 LTM에 저장되어있었던 것이죠. 그래서 정상적인 말 배치로 진행했을 때는 기억해 내는 데 유리할 수 있었지만 임의의 배치로 진행했을 때는 전문가/비전문가 모두 STM에 의지해 복기해야했습니다.

여기서 오프닝을 알고있는 전문가들이 한 방법이 바로 청크를 이용한 방법입니다. '시실리언 오프닝' 전체가 STM에 하나의 단위로 저장되어 사용되는 것이죠.

라면을 처음 끓인다면 물을 붓고, 물을 끓이고, 면과 수프를 넣고 4분 더 끓인 뒤 마지막에 계란이나 대파를 넣는다는 것을 모두 STM에 저장하고 실행에 옮겨야하지만, 라면을 많이 끓여본 사람들은 LTM에서 꺼내 하나의 STM으로 저장할 수 있습니다.

중간에 한 스텝이 달라진다고해도 하나의 청크로 묶는 것이 가능해집니다. 예를 들어 그냥 라면이 아니라 짜파게티처럼 중간에 물을 버리는 과정이 필요하다고하면, 그것을 일일히 하나의 스텝으로 인지하지 않는 것 처럼요.

비슷하게 아래 세 가지 예시를 5초만 보고 기억해봅시다.

**예시 1**
```text
άλφα βήτα γάμα
```

5초 뒤 동일하게 적을 수 있을까요?

**예시 2**
```text
ajka betz japz
```

이 문장은 예시 1 보다는 많이 기억할 수 있을 것입니다. 우리가 아는 문자로 되어있기 때문입니다. 예시 1과 같은 길이를 가지고 중복 여부 또한 동일합니다.

**예시 3**
```text
cat loves cake
```

마지막 문장은 아마 대부분 쉽게 기억했을 것입니다. 기억해야할 단어가 세 개 이므로 STM을 3개만 사용하면 되고 다른 인지나 연산이 필요하지 않기 떄문입니다.

특정 주제에 대해 두뇌가 더 많은 정보를 저장하고 있다면 입력된 정보들을 청크로 묶어 효율적으로 활용할 수 있다는 것을 알 수 있습니다. 이는 결국 STM에 저장되었던 부분이 LTM에 많이 저장될 수록 수월하다는 뜻이기도 합니다.

### 전문가는 초보자보다 코드를 잘 기억한다

체스 복기와 비슷한 실험을 초급, 중급, 고급 프로그래머에게 프로그램을 보여주면서 기억해보게 하였습니다. 처음은 실제 프로그램 코드였고, 두 번째 실험은 코드 줄을 무작위로 섞어 놓았습니다.

실험 결과는 체스 때와 비슷했습니다. 섞지 않은 코드에서는 고급 > 중급 > 초급 순으로 많이 기억했고 섞은 코드에서는 미세하게 앞서긴 했지만 크게 차이나지 않았습니다.

이 실험의 가장 중요한 결과는 초보 프로그래머들이 숙련된 프로그래머보다 훨씬 적은 줄을 처리한다는 점입니다. 따라서 신입 개발자나 주니어 개발자와 소통할 때, 또는 새로운 언어를 배울 때는 이 점을 기억해야 합니다.

심지어 숙련된 프로그래머도 익숙하지 않은 언어나 도메인에서 일할 때는 LTM에 저장하는데 시간을 많이 소모하기 때문에 어려움을 겪게 됩니다.

---

다음 포스팅에서 이어집니다!