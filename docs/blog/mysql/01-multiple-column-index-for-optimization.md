## 다중 컬럼 인덱스(Multiple-Column Index)를 통한 성능 최적화

### 다중 컬럼 인덱스의 이해

다중 컬럼 인덱스는 복합 인덱스(composite index)라고도 알려져 있고 이는 테이블의 여러 컬럼을 조합해서 구성하는 인덱스를 말합니다.

(이하 다중 컬럼 인덱스를 복합 인덱스라고 칭하겠습니다.)

MySQL에선 최대 16개의 컬럼을 조합해 복합 인덱스를 구축할 수 있습니다.

여기서 중요한 건 복합 인덱스는 명시한 컬럼의 순서대로 정렬되어 있어 쿼리 성능에 큰 영향을 미친다는 점입니다.

예를 들어, 회원의 정보를 저장하는 테이블에 (이름, 나이)로 복합 인덱스를 구성했을 경우 인덱스의 정렬 순서는 아래와 같습니다.

1. 이름 순서대로 정렬
2. 그 이후에 나이 순서대로 정렬

여기서 나이만으로 쿼리를 수행할 경우 인덱스 풀스캔이 발생합니다.

반대로 이름만으로 쿼리를 수행할 경우엔 인덱스가 잘 적용됩니다.

이렇게 복합 인덱스가 명시된 컬럼 순으로 정렬되기 때문에 가장 선행되는 컬럼을 조건절에 먼저 사용하지 않으면 쿼리에서 인덱스를 사용할 수 없는 경우가 발생할 수 있습니다.

예외적으로 인덱스 스킵 스캔(Index Skip Scan)을 사용할 수 있습니다.

> 인덱스 스킵 스캔이란 데이터베이스 쿼리에서 인덱스를 사용해 검색하는 방법 중 하나로, 일반적으로 인덱스는 전체 테이블의 모든 행을 찾는 데 사용되지만, 특정 상황에서 인덱스를 스킵할 수 있는 기능입니다.
> 
> 복합 인덱스에서 일부 컬럼만 사용할 경우, 다수의 컬럼에 대한 쿼리가 있을 경우 일반적인 인덱스 스캔보다 효율적일 수 있습니다.

### 복합 인덱스를 효율적으로 설계하는 방법

일반적인 복합 인덱스 설계의 기준은 카디널리티(Cardinality) 입니다.

> 카디널리티란?
> 
> 데이터베이스에서 관계형 모델에서 사용되는 개념으로, 한 테이블의 열(컬럼)이 가질 수 있는 고유한 값의 수를 나타냅니다. 즉, 카디널리티는 해당 열에 있는 서로 다른 값의 개수를 의미합니다.
> 
> 카디널리티는 크게 세 가지 유형으로 나뉩니다.
> 
> 고유 카디널리티 (Unique Cardinality): 특정 열에 대해 모든 행이 서로 다른 값을 가지는 경우를 나타냅니다. 예를 들어, 주민등록번호와 같이 각 행이 고유한 값을 가져야 하는 경우입니다.
> 
> 저카디널리티 (Low Cardinality): 특정 열에 대해 값의 다양성이 낮아서 중복된 값이 많은 경우를 나타냅니다. 예를 들어, 성별 열이 있을 때 "남성" 또는 "여성"처럼 제한된 값들이 많이 반복되는 경우입니다.
> 
> 고카디널리티 (High Cardinality): 특정 열에 대해 값의 다양성이 높아서 중복된 값이 거의 없는 경우를 나타냅니다. 예를 들어, 고객의 이메일 주소와 같이 대부분의 행이 서로 다른 값을 가지는 경우입니다.

카디널리티가 높은 컬럼을 복합 인덱스의 선행 컬럼으로 두는 것입니다.

카디널리티를 확인하는 방법은 다음과 같습니다.

* 이미 인덱스를 생성한 경우: 인덱스 통계 테이블을 통해 확인 가능
* 아직 인덱스를 생성하지 않은 경우: MySQL 8.0부터 추가된 기능인 히스토그램을 통해 확인 가능
```sql
analyze
table your_table
update histogram for portion your_column
with 100 buckets; -- 히스토그램을 몇 개의 버킷(구간)으로 나눌지 결정
```

그러나 여기서 중요한 것은, 카디널리티만 고려해서 인덱스를 설계하면 안 된다는 것입니다.

카디널리티 외에 고려해야할 사항은 아래와 같습니다.

- 자주 사용하는 쿼리가 무엇인가?
  - 특정 컬럼을 단독으로 사용하는 쿼리들도 많다면 해당 컬럼이 카디널리티가 낮더라도 인덱스의 선행 컬럼으로 둘 수 있음 
- `join`에도 인덱스가 사용되는가?
  - `join`에 자주 사용되는 컬럼을 선행 컬럼으로 두면 `join` 처리에 도움이 됨
- 인덱스의 선행 컬럼이 범위 기반의 쿼리로 많이 이용되는가?
  - 카디널리티가 높더라도 많은 범위의 인덱스 탐색이 이루어질 수 있기 때문에 선행 컬럼으로 적합하지 않음
- 인덱스를 설계했을 때 슬로우 쿼리가 발생할 가능성이 있는가?

### 복합 인덱스가 너무 많은 경우

여러 컬럼을 조합해서 `hashed` 컬럼을 만들어 성능 향상을 기대할 수 있습니다.

복합 인덱스를 구성하는 모든 컬럼을 조합한 이후 해시 함수를 적용한 컬럼으로, `hashed` 컬럼에 인덱스를 적용하면 하나의 컬럼으로 인덱스 검색을 하게되어 성능적으로 이득을 볼 수 있습니다.

```sql
select *
from your_table
where hashed_column = md5(concat(val1, v1l2))
  and col1 = val1
  and col2 = val2;
```

이렇게 함으로써 다양한 쿼리에 유연하게 대응할 수 있습니다.